# Quality Gate 결과 — F-02 취약점 탐지 엔진 (Python)

**검증일**: 2026-02-25  
**검증자**: quality-gate  
**대상 브랜치**: main  
**검토 파일**:
- `backend/src/services/semgrep_engine.py`
- `backend/src/services/llm_agent.py`
- `backend/src/workers/scan_worker.py`
- `backend/src/services/vulnerability_mapper.py`
- `backend/src/rules/python/sql_injection.yml`
- `backend/src/rules/python/xss.yml`
- `backend/src/rules/python/hardcoded_creds.yml`

---

## 보안

### Critical

없음

### Warning

**W-SEC-01: REDIS_URL이 시작 로그에 평문 노출**

- 파일: `backend/src/workers/scan_worker.py`, 375번 줄
- 코드: `logger.info(f"[ScanWorker] 워커 시작 (Redis: {settings.REDIS_URL})")`
- 위험: Redis URL에 인증 정보(비밀번호)가 포함된 경우 (`redis://:password@host:port`) 로그 수집기(CloudWatch, Datadog, Railway 로그)에 평문 노출됨.
- 권장: URL의 호스트/포트만 추출하여 로그에 기록하거나, `[REDACTED]` 마스킹 처리 필요.

**W-SEC-02: Semgrep `file_path` path traversal 미검증 (부분적)**

- 파일: `backend/src/workers/scan_worker.py`, 243번 줄
- 코드: `abs_path = temp_dir / file_path`
- 위험: `SemgrepFinding.file_path`는 Semgrep JSON 출력에서 파싱한 값이며, `../../` 등의 경로가 포함될 경우 `temp_dir` 외부 파일을 읽을 수 있음. Semgrep 자체 신뢰도가 높아 실제 공격 벡터 가능성은 낮지만, 악의적으로 조작된 룰 파일(룰 디렉토리 오염)이나 Semgrep 바이너리 교체 시나리오에서 위험 존재.
- `_parse_results`에서 `relative_to(base_dir)` 처리로 1차 방어가 되어 있으나, Semgrep JSON을 직접 신뢰하는 구조는 잠재적 위험.
- 권장: `abs_path.resolve().is_relative_to(temp_dir)` 검증 추가.

**W-SEC-03: `hardcoded_creds.yml` — `pattern-not-regex` 적용 범위 불일치**

- 파일: `backend/src/rules/python/hardcoded_creds.yml`, 27번 줄
- 코드:
  ```yaml
  patterns:
    - pattern: |
        password = "..."
    ...
  pattern-not-regex: '.*=\s*""\s*$'   # 빈 문자열은 제외
  ```
- 위험: Semgrep에서 `patterns` 블록과 `pattern-not-regex` 최상위 혼용 시, `pattern-not-regex`가 각 개별 패턴에 적용되지 않고 무시될 수 있음 (Semgrep 문법상 `pattern-not-regex`는 `pattern` 단수와 함께 사용해야 함). 의도한 빈 문자열 제외가 동작하지 않을 가능성 있음.
- 권장: `patterns` 블록 내에 `- pattern-not-regex:` 항목으로 이동시켜야 함.

**W-SEC-04: LLM 응답 `_parse_analysis_response` — JSON 파싱 실패 시 예외 미처리**

- 파일: `backend/src/services/llm_agent.py`, 368~370번 줄
- 코드:
  ```python
  def _parse_analysis_response(self, response: str) -> list[dict]:
      cleaned = self._strip_json_wrapper(response)
      parsed = json.loads(cleaned)  # JSONDecodeError 발생 시 호출자로 전파
      return parsed.get("results", [])
  ```
- 위험: `analyze_findings()` 호출 시 `_parse_analysis_response`의 `JSONDecodeError`가 uncaught로 전파되어 해당 파일의 모든 findings를 드롭함. `_generate_patch`는 try/except로 보호되어 있으나 1차 분석 응답 파싱은 미보호.
- 설계서(5-2절)에서는 "JSON 파싱 실패 시 경고 로그, 해당 파일의 findings를 Semgrep 결과만으로 저장"을 명시하고 있으나 구현은 예외를 그대로 전파함.
- 권장: `_parse_analysis_response`에 `try/except json.JSONDecodeError` 추가, 실패 시 빈 목록 반환 + 경고 로그.

**W-SEC-05: `start_worker()`에서 REDIS_URL 신뢰 — 연결 실패 시 에러 핸들링 없음**

- 파일: `backend/src/workers/scan_worker.py`, 366~376번 줄
- `redis.from_url()` 호출 실패 시 예외가 전파되어 워커 프로세스가 비정상 종료됨. 운영 환경에서 Redis 연결 실패 시 명시적 에러 메시지 없이 크래시.

### Pass

- API 키 하드코딩 없음: `ANTHROPIC_API_KEY`는 `src/config.py`의 pydantic-settings를 통해 환경변수에서 로드됨. 코드 내 하드코딩 없음.
- 로그에 API 키 미노출: `logger.*` 호출에서 `ANTHROPIC_API_KEY`, `JWT_SECRET_KEY`, `GITHUB_APP_PRIVATE_KEY` 등 민감 값 출력 없음.
- LLM 시스템 프롬프트 인젝션 방어 (기본): `_ANALYSIS_SYSTEM_PROMPT`가 별도 `system=` 파라미터로 전달되어 사용자 콘텐츠(코드)와 시스템 지시가 분리됨. Anthropic API의 `system` 파라미터 분리 구조 자체가 1차 방어.
- 임시 디렉토리 경로 고정: `Path(f"/tmp/vulnix-scan-{job_id}")` — `job_id`가 UUID 형식이므로 경로 예측 어려움.

---

## 성능

### Critical

없음

### Warning

**W-PERF-01: `_save_vulnerabilities`의 finding_map 인덱스 — 동일 rule_id 다중 파일 findings 손실**

- 파일: `backend/src/workers/scan_worker.py`, 282~285번 줄
- 코드:
  ```python
  finding_map: dict[str, SemgrepFinding] = {}
  for f in findings:
      if f.rule_id not in finding_map:
          finding_map[f.rule_id] = f  # 첫 번째 finding만 보존
  ```
- 위험: 동일 `rule_id`가 여러 파일에서 발생할 경우 (예: `vulnix.python.sql_injection.string_format`이 `app/db.py`와 `app/views.py` 양쪽에서 탐지) 두 번째 이후 findings는 DB에 저장되지 않음. 오탐 필터 후에도 동일 rule_id의 복수 취약점이 누락될 수 있음.
- 권장: `finding_map`의 키를 `(rule_id, file_path, start_line)` 복합 키로 변경하고, `LLMAnalysisResult.finding_id`도 이에 맞게 매칭.
- 이는 features.md 인수조건 "탐지 정확도 80% 이상"에 영향을 줄 수 있음.

**W-PERF-02: `get_async_session()`에서 매 스캔마다 엔진 생성/삭제**

- 파일: `backend/src/workers/scan_worker.py`, 42~61번 줄
- `create_async_engine()`과 `engine.dispose()`를 매 스캔 작업마다 반복 호출함. 커넥션 풀을 재사용하지 않아 DB 연결 오버헤드 발생. 워커 프로세스 수명 동안 엔진을 싱글톤으로 유지하는 것이 권장 패턴.

### Pass

- `asyncio.Semaphore(max_concurrent=5)` 적용: `_run_llm_analysis_batch`에서 동시 LLM 호출 수를 5로 제한하여 rate limit 대응 완료.
- 500줄 초과 파일 토큰 최적화 구현: `_prepare_file_content()`에서 500줄 초과 + findings 5건 미만 조건에서 `±50줄` 슬라이딩 윈도우 추출 완료.
- findings 없으면 LLM 스킵: `analyze_findings()`의 첫 줄에서 `if not findings: return []` 처리.
- Semgrep 스캔 이후 findings가 0건이면 LLM 배치 분석 전체 스킵하고 `completed` 처리.
- `asyncio.gather(*tasks, return_exceptions=True)` 사용: 개별 파일 분석 실패가 전체 배치를 중단시키지 않음.
- rate limit 지수 백오프 재시도: `_call_claude_with_retry`에서 `RateLimitError` 2초/4초/8초 재시도, `APITimeoutError` 및 5xx 서버 에러도 재시도 로직 존재.

---

## 설계/문서 일치

### 설계 불일치

**D-01: `_enrich_with_references()` 미구현**

- 설계서(`design.md` 3-2-1절) 흐름:
  ```
  analyze_findings()
    |-> _enrich_with_references()  # CWE/OWASP 참조 링크 추가
  ```
- 구현(`llm_agent.py`): `_enrich_with_references()` 메서드 없음. `references` 필드가 항상 빈 목록(`[]`)으로 반환됨.
- 영향: `LLMAnalysisResult.references`가 항상 비어 있어 취약점 상세 화면에서 참조 링크 미표시.

**D-02: 설계서의 `_save_vulnerabilities` finding_map 구현 방식 차이**

- 설계서(`design.md` 3-4-2절):
  ```python
  finding_map = {f.rule_id: f for f in findings}  # 딕셔너리 컴프리헨션
  ```
- 구현(`scan_worker.py`, 282~285번 줄): 첫 번째 finding만 보존하는 루프 방식으로 구현됨.
- 설계서 버전도 동일한 문제(동일 rule_id 덮어씀)를 가지나, 구현 방식이 설계서와 미세하게 다름.

**D-03: `sql_injection.yml` — Django/SQLAlchemy 추가 룰 설계 대비 구현 차이**

- 설계서(`design.md` 3-5-1절)에서 `django_raw` 룰의 `pattern` 3가지 + `django_extra` 룰의 `pattern` 2가지를 명시.
- 구현(`sql_injection.yml`)에는 `django_raw`, `django_extra` 룰 자체가 없음 (3개 룰만 존재: `string_format`, `string_concat`, `sqlalchemy_text`).
- 설계서에서 "개선" 유형으로 분류한 Django 추가 룰이 실제 yml 파일에 반영되지 않았음.
- 단, `vulnerability_mapper.py`에는 `django_raw`, `django_extra` rule_id 매핑이 존재하여 매퍼-룰 간 불일치 발생.

**D-04: `xss.yml` — `fastapi_html_response` 룰 미구현**

- 설계서(`design.md` 3-5-2절)에서 FastAPI HTMLResponse 패턴 3가지를 추가하도록 명시.
- 구현(`xss.yml`)에는 해당 룰 없음 (4개 룰만 존재: `flask_render_html`, `flask_markup_unsafe`, `jinja2_autoescape_disabled`, `django_mark_safe`).
- `vulnerability_mapper.py`에는 `vulnix.python.xss.fastapi_html_response` 매핑이 존재하여 매퍼-룰 간 불일치.

**D-05: `hardcoded_creds.yml` — `jwt_secret`, `private_key` 룰 미구현**

- 설계서(`design.md` 3-5-3절)에서 `jwt_secret` 룰 3가지 패턴과 `private_key` 룰 pattern-regex를 추가하도록 명시.
- 구현(`hardcoded_creds.yml`)에는 해당 룰 없음 (4개 룰만 존재: `password_assignment`, `api_key`, `aws_access_key`, `db_connection_string`).
- `vulnerability_mapper.py`에는 `jwt_secret`, `private_key` 매핑 존재하여 매퍼-룰 간 불일치.

### 인수조건 충족

- 인수조건 "Semgrep 룰 기반 1차 AST 분석으로 후보 취약점 추출": 충족. `SemgrepEngine.scan()` 구현 완료.
- 인수조건 "Claude API 2차 분석으로 컨텍스트 기반 오탐 필터링": 충족. `LLMAgent.analyze_findings()` 구현 완료.
- 인수조건 "SQL Injection 취약점 탐지 가능 (Python 코드 대상)": 부분 충족. `string_format`, `string_concat`, `sqlalchemy_text` 3가지 기본 패턴은 탐지 가능. Django ORM 패턴(`django_raw`, `django_extra`) 미구현.
- 인수조건 "XSS 취약점 탐지 가능 (Python 웹 프레임워크 대상)": 부분 충족. Flask, Django, Jinja2 탐지 가능. FastAPI 미구현.
- 인수조건 "Hardcoded Credentials 탐지 가능": 부분 충족. 기본 4가지 패턴 구현. JWT Secret, Private Key 패턴 미구현.
- 인수조건 "심각도 분류: Critical / High / Medium / Low / Informational": 충족. LLM 프롬프트 및 `LLMAnalysisResult.severity` 필드에 5단계 정의.
- 인수조건 "각 취약점에 OWASP Top 10, CWE ID 매핑": 충족. `vulnerability_mapper.py` + `LLMAnalysisResult.owasp_category` 필드.

### 인수조건 미충족

- 인수조건 "각 취약점에 OWASP Top 10, CWE ID 매핑" (참조 링크): `LLMAnalysisResult.references`가 항상 빈 목록. `_enrich_with_references()` 미구현으로 CWE/OWASP 참조 URL 미생성. (D-01 참조)
- Django raw()/extra() SQL Injection 패턴 탐지: yml 룰 미구현으로 해당 패턴 탐지 불가. (D-03 참조)
- FastAPI HTMLResponse XSS 패턴 탐지: yml 룰 미구현으로 해당 패턴 탐지 불가. (D-04 참조)
- JWT Secret/Private Key 하드코딩 탐지: yml 룰 미구현으로 해당 패턴 탐지 불가. (D-05 참조)

---

## 시각 검증

생략: 프론트엔드 변경 없음 (백엔드/워커 전용 기능)

---

## 코드 품질

### 긍정 사항

- `try-finally` 임시 디렉토리 정리 보장: `_run_scan_async()`의 `finally` 블록에서 `SemgrepEngine.cleanup_temp_dir(message.job_id)` 호출, ADR-003 준수.
- `cleanup_temp_dir` 에서 `try/except OSError`로 삭제 실패 시 경고만 기록하고 예외 미전파 — 올바른 패턴.
- pydantic-settings 기반 설정 관리: 환경변수 누락 시 앱 시작 단계에서 실패 (Fail Fast 패턴).
- `temperature=0.0` 설정으로 LLM 응답 일관성 확보.
- `asyncio.iscoroutinefunction(scalar_one)` 패턴: 테스트 환경(AsyncMock)과 프로덕션 환경 양쪽을 지원하는 방어적 코드.

### 잠재적 문제

- `LLMAgent.__init__`에서 `anthropic.AsyncAnthropic` 생성 실패 시 `unittest.mock.MagicMock`으로 폴백 (62~66번 줄): 프로덕션 코드에 테스트 전용 의존성(`unittest.mock`)이 포함됨. 환경에 따라 조건 분기하거나 별도 팩토리로 분리 권장.
- `_run_scan_async` 내 `try` 블록이 `async with get_async_session()` 안에 있어, DB 세션 획득 전 오류(예: DB 연결 실패)는 `orchestrator.update_job_status("failed")` 호출 불가.

---

## 종합 판정

FAIL — Critical 이슈 0건, Warning 이슈 5건, 설계 불일치 5건 (룰 파일 3건 미구현 포함)

**수정 필요 항목 우선순위**:

1. (필수, 기능 누락) D-03, D-04, D-05: `sql_injection.yml`, `xss.yml`, `hardcoded_creds.yml`에 설계서 지정 추가 룰 구현 — 인수조건 미충족 상태.
2. (필수, 기능 누락) D-01: `_enrich_with_references()` 구현 또는 `references` 필드를 CWE/OWASP URL로 채우는 로직 추가.
3. (권장) W-PERF-01: `finding_map`을 복합 키 `(rule_id, file_path, start_line)`로 변경하여 동일 rule_id 복수 탐지 손실 방지.
4. (권장) W-SEC-04: `_parse_analysis_response`에 `JSONDecodeError` 예외 처리 추가.
5. (선택) W-SEC-01: REDIS_URL 로그 마스킹.
6. (선택) W-SEC-02: `abs_path.resolve().is_relative_to(temp_dir)` path traversal 검증 추가.
