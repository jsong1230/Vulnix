# Quality Gate 결과: F-11 IDE 플러그인 백엔드

검증일: 2026-02-25 17:00  
검증 브랜치: main  
검증자: quality-gate

---

## 검토 대상 파일

- `backend/src/api/v1/ide.py`
- `backend/src/models/api_key.py`
- `backend/src/services/api_key_service.py`
- `backend/src/services/ide_analyzer.py`
- `backend/src/api/deps.py`
- `backend/alembic/versions/007_add_f11_tables.py`

---

## 보안

### Critical

없음.

### Warning

**W-01: timing-safe 비교 부재 (deps.py:124-128)**

`get_api_key` 함수에서 `key_hash`를 SHA-256으로 계산한 후 SQL WHERE 절로 DB에서 조회한다. DB 레벨 비교는 Python `hmac.compare_digest` 와 달리 일정 시간(constant-time) 보장이 없다. 공격자가 네트워크 타이밍을 반복 측정하여 해시 접두사를 추론할 여지가 있다. 설계서 ADR-F11-004 에서 별도 언급이 없어 Warning 수준으로 분류하지만, 향후 Redis 캐시(API Key -> team_id 매핑) 도입 시 Python 레벨 비교로 이동될 경우 반드시 `hmac.compare_digest` 를 사용해야 한다.

파일: `backend/src/api/deps.py` 라인 124-128

```python
key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()
result = await db.execute(
    select(ApiKey).where(ApiKey.key_hash == key_hash)
)
```

**W-02: list_api_keys에서 revoked 키 필터링 누락 (ide.py:261-267)**

주석에는 "revoked_at이 없는 것만"이라고 명시되어 있으나, 실제 쿼리에는 `revoked_at IS NULL` 또는 `is_active = TRUE` 필터가 없다. 비활성화된 API Key가 목록에 그대로 노출된다.

파일: `backend/src/api/v1/ide.py` 라인 261-267

```python
# API Key 목록 조회 (revoked_at이 없는 것만)  <-- 주석과 실제 코드 불일치
result = await db.execute(
    select(ApiKey).where(
        ApiKey.team_id == team_id,
        # is_active 또는 revoked_at 필터 없음
    )
)
```

비교: `api_key_service.py` `list_keys` 메서드(라인 89-95)에는 `ApiKey.revoked_at == None` 필터가 올바르게 적용되어 있으나, `ide.py`의 `list_api_keys` 엔드포인트는 서비스 메서드를 재사용하지 않고 직접 쿼리를 작성하면서 누락됐다.

**W-03: 임시 디렉토리 경로 충돌 가능 (ide_analyzer.py:52-53)**

`request_id = str(uuid.uuid4())[:8]`으로 UUID v4 128비트 중 8 hex 문자(32비트)만 사용한다. 생일 역설 기준 약 65,536 동시 요청에서 충돌 확률이 50%를 넘는다. 충돌 시 `mkdir(exist_ok=True)` 로 인해 다른 요청의 임시 디렉토리에 파일을 덮어쓰는 레이스 컨디션이 발생한다.

파일: `backend/src/services/ide_analyzer.py` 라인 52-53

```python
request_id = str(uuid.uuid4())[:8]
temp_dir = Path(f"/tmp/vulnix-ide-{request_id}")
```

`semgrep_engine.py`의 `prepare_temp_dir`은 전체 job_id를 사용하는 것과 대조적이다.

**W-04: Rate Limit 미구현 (IDE 엔드포인트 전체)**

설계서 3-2절에서 Redis 기반 sliding window counter를 사용한 Rate Limit을 명시하였다:

| 엔드포인트 | 제한 |
|-----------|------|
| POST /ide/analyze | 60회/분 |
| GET /ide/false-positive-patterns | 30회/분 |
| POST /ide/patch-suggestion | 10회/분 |

현재 `ide.py`, `deps.py`, `api_key_service.py` 어디에도 Rate Limit 구현이 없다. Redis는 `pyproject.toml`에 의존성으로 포함되어 있으나 IDE 엔드포인트에서 사용되지 않는다. 특히 LLM을 호출하는 `patch-suggestion` 엔드포인트는 비용 폭발 위험이 있다.

### 통과

- **API Key 원본 값 노출 통제**: `create_key` (api_key_service.py:71-78)에서만 원본 `key` 반환. `list_api_keys` (ide.py:269-279)는 `key_prefix`만 반환하여 설계 의도 충족.
- **SHA-256 해시 저장**: DB에 원본 키 대신 `key_hash` (SHA-256 64자)만 저장. `api_key.py:41-47` 확인.
- **팀 소속 검증**: `create_api_key` 및 `revoke_api_key`에서 `TeamMember` 조회로 팀 소속 확인 (ide.py:204-209, 303-308). `revoke_key` 서비스에서 `ApiKey.team_id == team_id` 조건으로 교차 팀 접근 방지 (api_key_service.py:114-118).
- **만료/비활성 검증**: `get_api_key` (deps.py:136-154)에서 `is_active`, `expires_at` 순서대로 검증.
- **Semgrep 코드 미실행**: `semgrep_engine.py`는 `subprocess.run`으로 Semgrep CLI를 실행하고 결과를 JSON 파싱만 함. 사용자 코드를 `eval`/`exec`하는 경로 없음.
- **임시 파일 정리**: `ide_analyzer.py:87-93`에서 `finally` 블록으로 `shutil.rmtree(temp_dir)` 실행. 삭제 실패 시 예외 아닌 경고 로그로 처리하여 서비스 중단 없이 정리.
- **RBAC 적용**: `create_api_key`, `revoke_api_key` 엔드포인트에서 `role not in ("owner", "admin")` 검증 (ide.py:219-223, 317-321).
- **로그에 민감 정보 미출력**: `ide_analyzer.py` 로그에 `request_id`와 에러 메시지만 기록. 코드 내용(`content`) 미로깅.

---

## 성능

### Warning

**W-05: Semgrep 500ms 타임아웃 적용 확인 — 단, 프로세스 종료 없음**

`_run_semgrep_with_timeout` (ide_analyzer.py:95-136)에서 `asyncio.wait_for(..., timeout=0.5)`로 Python 레벨 코루틴 타임아웃은 적용되어 있다. 그러나 `executor`로 실행된 `semgrep scan` 프로세스는 `asyncio.TimeoutError` 발생 후에도 백그라운드에서 계속 실행된다. Semgrep 프로세스가 종료되지 않고 남아 CPU/메모리를 소모하며, 동시 요청이 많을 경우 좀비 프로세스가 누적된다.

파일: `backend/src/services/ide_analyzer.py` 라인 104-133

```python
findings = await asyncio.wait_for(
    loop.run_in_executor(
        None,
        lambda: self._engine.scan(temp_dir, request_id),
    ),
    timeout=_IDE_ANALYZE_TIMEOUT_SEC,
)
```

참고: Semgrep CLI 자체에는 `--timeout 300` (semgrep_engine.py:65)이 설정되어 있어 Semgrep 내부 룰 타임아웃은 존재하지만, IDE 엔드포인트에서 500ms를 초과하면 asyncio 레벨에서만 포기하고 프로세스는 살아 있다.

### 통과

- **Semgrep 500ms 타임아웃 설정**: `_IDE_ANALYZE_TIMEOUT_SEC = 0.5` (ide_analyzer.py:20) 로 정의되고 `asyncio.wait_for`에 적용됨.
- **임시 파일 경로**: UUID 기반 디렉토리로 경로 예측 불가 (W-03에서 길이 이슈 언급, 기능 자체는 동작).
- **인덱스 설계 반영**: 마이그레이션(007)에서 `idx_api_key_hash` (UNIQUE), `idx_api_key_team`, `idx_api_key_active` 부분 인덱스 모두 적용됨. 설계서 8-3절 인덱스 계획 충족.
- **ETag 캐싱**: `false-positive-patterns` 엔드포인트에 SHA-256 기반 ETag 생성 및 304 응답 구현 (ide.py:116-126).

---

## 설계/문서 일치

### 설계 불일치

**D-01: 헤더 이름 불일치 — 설계서 `X-API-Key` vs 구현 `X-Api-Key`**

설계서(design.md:43, 68, 131, 169) 및 test-spec.md(라인 81-82)에서 `X-API-Key`로 명시. 구현 코드(deps.py:101)와 API 문서(docs/api/F-11-ide-plugin.md:12)는 `X-Api-Key`로 구현. HTTP 헤더는 대소문자를 무시하므로 실제 동작에는 문제없으나 문서 일관성이 없다.

**D-02: `list_api_keys` — `ApiKeyService.list_keys` 미사용**

`api_key_service.py:80-95`에 `list_keys` 메서드가 구현되어 있고 `revoked_at IS NULL` 필터를 올바르게 포함한다. 그러나 `ide.py`의 `list_api_keys` 엔드포인트(라인 250-286)는 이 메서드를 호출하지 않고 직접 쿼리를 재작성하면서 필터를 누락시켰다 (W-02와 동일 이슈).

**D-03: 설계서 INVALID_LANGUAGE 에러 vs 실제 422 응답**

설계서(design.md:118-119)는 지원하지 않는 언어 요청 시 `400 INVALID_LANGUAGE`를 명시. API 문서(docs/api/F-11-ide-plugin.md)는 `422`로 수정 기록됨. 실제 구현에서 `IdeAnalyzeRequest.validate_language` Pydantic validator가 유효하지 않은 언어를 거부하면 FastAPI는 기본적으로 `422 Unprocessable Entity`를 반환한다. 설계서와 구현 간 불일치가 있으나 API 문서가 이를 반영하고 있어 API 문서 기준으로는 일치.

### 문서 불일치

**D-04: 설계서 Redis 캐싱 전략 미구현**

설계서 8-4절에서 "API Key -> team_id 매핑을 Redis에 TTL 5분으로 캐싱"을 명시하였으나, 구현 코드에서 이 캐싱은 전혀 구현되지 않았다. 현재 모든 IDE API 요청마다 DB를 조회한다.

### 인수조건 충족

- **코드 작성 중 실시간 취약점 하이라이팅**: 백엔드 `POST /ide/analyze` 엔드포인트 구현, Semgrep 500ms 타임아웃으로 IDE에 최적화된 응답 구조 제공. 충족.
- **취약점 위치에 인라인 패치 제안 표시**: 백엔드 `POST /ide/patch-suggestion` 엔드포인트 구현. 충족.
- **패치 제안 수락 시 코드 자동 수정**: 백엔드 측 `generate_patch` 응답 구조(`patch_diff`, `patch_description`) 구현. 충족 (VS Code 측 적용 로직은 이번 검토 범위 외).
- **취약점 상세 설명 패널**: 백엔드 응답에 `cwe_id`, `owasp_category`, `vulnerability_type` 포함. 충족.
- **팀 오탐 규칙 동기화**: `GET /ide/false-positive-patterns` + ETag 캐싱 구현. 충족.

### 인수조건 미충족

- **Rate Limit**: 설계서 명시 Rate Limit 미구현. 특히 `patch-suggestion`의 분당 10회 제한 부재.

---

## 시각 검증

생략: 백엔드 전용 기능으로 ui-spec.md 없음.

---

## Alembic 마이그레이션 체인 확인

- `007_add_f11_tables.py:19` — `down_revision = "006_add_f10_tables"` 확인. 체인 정상.
- `006_add_f10_tables.py` 존재 확인. 선행 마이그레이션 의존성 정상.

---

## 종합 판정

**PASS (조건부)** — Critical 이슈 0건. Warning 5건.

| 이슈 ID | 분류 | 요약 | 파일:라인 |
|---------|------|------|----------|
| W-01 | Warning | API Key 조회가 DB 레벨 비교로만 처리 (constant-time 미보장) | deps.py:124-128 |
| W-02 | Warning | list_api_keys에서 revoked 키 필터 누락 (주석-코드 불일치) | ide.py:261-267 |
| W-03 | Warning | 임시 디렉토리 request_id를 UUID[:8]로 자름 (32비트 충돌 위험) | ide_analyzer.py:52-53 |
| W-04 | Warning | Rate Limit 미구현 (설계서 명시, 특히 patch-suggestion LLM 비용 위험) | ide.py 전체 |
| W-05 | Warning | 500ms 타임아웃 초과 시 Semgrep 프로세스가 백그라운드에 잔존 | ide_analyzer.py:104-133 |

W-02는 기능 버그(비활성화된 키 노출)에 해당하므로 수정이 권장된다.  
W-04(Rate Limit)는 LLM 비용 및 서비스 안정성과 직결되므로 프로덕션 배포 전 필수 구현이 필요하다.

---

# Quality Gate 결과: F-11 IDE 플러그인 VS Code 익스텐션 TypeScript

검증일: 2026-02-25 17:30
검증 브랜치: main
검증자: quality-gate
테스트 현황: 62/62 PASS (Jest)

---

## 검토 대상 파일

- `vscode-extension/src/api/types.ts`
- `vscode-extension/src/api/client.ts`
- `vscode-extension/src/config.ts`
- `vscode-extension/src/analyzer/fp-cache.ts`
- `vscode-extension/src/analyzer/analyzer.ts`
- `vscode-extension/src/diagnostics/diagnostic-mapper.ts`
- `vscode-extension/src/diagnostics/diagnostics.ts`
- `vscode-extension/src/code-actions/code-actions.ts`
- `vscode-extension/src/code-actions/patch-applier.ts`
- `vscode-extension/src/webview/panel-content.ts`
- `vscode-extension/src/webview/webview.ts`
- `vscode-extension/src/status/status-bar.ts`
- `vscode-extension/src/extension.ts`

---

## 보안

### Critical

없음.

### High

**H-01: vulnix.applyPatch 명령이 extension.ts에 미등록 (code-actions.ts:35)**

`code-actions/code-actions.ts` 35번째 줄에서 `vulnix.applyPatch` 명령을 CodeAction의 command로 지정한다. 그러나 `extension.ts` 전체 어디에도 `vscode.commands.registerCommand('vulnix.applyPatch', ...)` 핸들러가 없다. `package.json`의 `contributes.commands`에도 이 명령이 선언되어 있지 않다.

이로 인해 전구 아이콘을 클릭하여 "Apply Patch Fix"를 선택하면 VS Code가 `command not found` 에러를 발생시키고 패치가 실제로 적용되지 않는다. 패치 제안 수락 시 코드 자동 수정 기능이 완전히 동작하지 않는다.

파일: `vscode-extension/src/code-actions/code-actions.ts` 35번째 줄
```typescript
command: 'vulnix.applyPatch',
title: 'Apply Vulnix Patch',
arguments: [document.uri, diagnostic],
```

`vscode-extension/src/extension.ts`에 아래와 같은 핸들러가 없다:
```typescript
vscode.commands.registerCommand('vulnix.applyPatch', async (uri, diagnostic) => { ... })
```

수정 방법: `extension.ts`에 `vulnix.applyPatch` 명령 핸들러를 등록하고, `patch-applier.ts`의 `applyPatch()` 함수를 호출하도록 구현해야 한다. 또한 `package.json`의 `contributes.commands`에 해당 명령을 추가해야 한다.

### Warning

**W-01: API Key 형식 검증 미구현**

테스트 명세(test-spec.md:122)에서 "API Key 형식 검증: `vx_live_` 또는 `vx_test_` 접두사 확인"을 요구한다. `config.ts`의 `getApiKey()` 및 `isConfigured()`에는 `vx_live_` 또는 `vx_test_` 접두사 검증 로직이 없다. 빈 문자열 여부만 체크한다. 임의 문자열이 API Key로 설정되어도 설정 완료로 간주되며 서버 호출 후에야 401로 실패한다.

파일: `vscode-extension/src/config.ts` 33-37번째 줄

**W-02: 연속 저장 디바운스 미구현**

설계서 8-2절과 test-spec.md(U-18)에서 500ms 이내 연속 저장 시 API 호출을 1회로 묶는 디바운스를 명시한다. `analyzer.ts`와 `extension.ts` 어디에도 `setTimeout`/`clearTimeout` 기반 디바운스 로직이 없다. 짧은 시간에 파일을 연속 저장하면 API가 중복 호출된다.

파일: `vscode-extension/src/analyzer/analyzer.ts` (디바운스 로직 부재)

**W-03: FP 패턴 주기적 자동 동기화 미구현**

설계서 `fp-cache.ts` 설계(5-3절)에서 `syncPeriodically()` 메서드를 명시하고, 5분마다 `setInterval`로 `sync()`를 호출하도록 설계되어 있다. 구현된 `FPCache` 클래스에는 `syncPeriodically()` 메서드 자체가 없고, `extension.ts`에도 주기적 동기화 설정 코드가 없다. 현재는 사용자가 `vulnix.syncFPPatterns` 명령을 수동으로 실행해야만 패턴이 갱신된다.

파일: `vscode-extension/src/analyzer/fp-cache.ts` (syncPeriodically 부재)
파일: `vscode-extension/src/extension.ts` (주기적 sync 설정 부재)

**W-04: 설정 변경 감지(onDidChangeConfiguration) 미구현**

설계서 5-3절 `extension.ts` 설계에서 `onDidChangeConfiguration -> config.reload()` 이벤트 리스너 등록을 명시한다. test-spec.md(U-24)에서도 "serverUrl 변경 시 ApiClient 재초기화"를 인수조건으로 정의하고 있다. `extension.ts`에 `vscode.workspace.onDidChangeConfiguration` 리스너가 없어 서버 URL이나 API Key를 설정 변경해도 익스텐션을 재활성화하기 전까지 반영되지 않는다.

파일: `vscode-extension/src/extension.ts` (onDidChangeConfiguration 리스너 부재)

**W-05: WebviewPanel "Apply Patch" 버튼 메시지 핸들러 미구현**

설계서 `webview.ts` 설계(5-3절)에서 "메시지 핸들러: 'applyPatch' -> code-actions.applyPatch() 호출"을 명시한다. 현재 `webview.ts`의 `WebviewManager`에 `panel.webview.onDidReceiveMessage` 핸들러가 없고, `panel-content.ts` HTML에도 "Apply Patch" 버튼이 렌더링되지 않는다. 상세 패널에서 직접 패치를 적용하는 UX가 동작하지 않는다.

파일: `vscode-extension/src/webview/webview.ts` 16-39번째 줄
파일: `vscode-extension/src/webview/panel-content.ts` 42-83번째 줄

**W-06: patch-applier.ts 멀티라인 추가 시 줄바꿈 미처리**

`parseDiffToEdits()` 함수(patch-applier.ts:105)에서 추가 라인을 `hunk.addedLines.join('\n')`으로 결합한다. 이는 마지막 줄에 줄바꿈을 추가하지 않아 단일 `TextEdit`만 있는 경우 문서에 trailing newline 없이 텍스트가 삽입된다. 원본 diff에서 컨텍스트 라인(공백으로 시작하는 라인)도 `parseDiffToEdits`에서 완전히 무시되므로, 컨텍스트가 포함된 실제 unified diff에서 TextEdit의 범위가 실제 변경 라인과 어긋날 수 있다.

파일: `vscode-extension/src/code-actions/patch-applier.ts` 88-106번째 줄

---

## 성능

### Warning

**P-01: 디바운스 부재로 API 과호출 가능 (W-02와 연계)**

저장 시마다 즉시 API를 호출하므로, 자동 저장이 활성화된 환경(VS Code의 `files.autoSave: afterDelay`)에서 편집 중에도 반복적으로 서버 API를 호출한다. 설계서에서 명시한 500ms 디바운스가 없어 서버 부하와 rate limit 소진이 빠르다.

**P-02: 대용량 파일 경고 없이 조용히 스킵**

`analyzer.ts` 61번째 줄에서 1MB 초과 파일은 분석을 건너뛴다. 이 경우 사용자에게 어떤 알림도 표시되지 않는다(`return` 만 수행). 설계서 8-2절에서 "1MB 초과 파일은 자동 분석 생략 (수동 분석은 가능)"으로 명시하고 있으며, test-spec.md(U-17)에서는 "경고 메시지"를 예상 결과로 정의한다. 경고 없이 조용히 스킵되면 사용자는 왜 분석이 안 되는지 알 수 없다.

파일: `vscode-extension/src/analyzer/analyzer.ts` 60-63번째 줄

### 통과

- **비동기 분석**: API 호출이 `async/await` 기반 비동기로 구현되어 UI 스레드를 차단하지 않음.
- **1MB 파일 크기 제한**: `Buffer.byteLength(content, 'utf8') > MAX_FILE_SIZE` 조건으로 대용량 파일 API 호출 방지.
- **패치 제안 지연 로딩**: 전구 클릭 시에만 `vulnix.applyPatch` 명령을 통해 API 호출 (사전 호출 없음).
- **오탐 패턴 로컬 캐시**: `FPCache`가 `globalState`에 패턴을 영속화하여 반복 API 호출 없이 필터링 수행.

---

## 설계/문서 일치

### 설계 불일치

**D-01: `vulnix.applyPatch` 명령 미등록 (H-01과 동일)**

설계서 `code-actions.ts` 설계(5-3절)에서 `applyPatch(document, finding)` 흐름을 명시하고 있으나, `extension.ts`에 해당 명령 핸들러가 없다.

**D-02: WebviewPanel "Apply Patch" 버튼 미구현 (W-05와 동일)**

설계서 `webview.ts` 설계에서 "Apply Patch 버튼 → webview -> extension 메시지" 흐름을 명시했으나 구현되지 않았다.

**D-03: `syncPeriodically()` 메서드 미구현 (W-03과 동일)**

설계서 `fp-cache.ts` 설계에 `syncPeriodically()` 메서드가 명시되어 있으나 구현 클래스에 없다.

**D-04: `onDidChangeConfiguration` 리스너 미등록 (W-04와 동일)**

설계서 `extension.ts` 설계(이벤트 리스너 7번 항목)에 `onDidChangeConfiguration -> config.reload()` 등록이 명시되어 있으나 구현에 없다.

**D-05: 상태 표시줄 "0 issues" 초기 상태 미구현**

설계서 status-bar.ts 설계에서 `setConnected(0)` 형태의 초기 연결 상태를 표시하도록 설계되어 있다. 현재 `extension.ts` 133번째 줄에서 `statusBar.setOffline()`으로 초기화하는데, 이는 서버 연결 여부를 확인하지 않고 항상 오프라인으로 초기화한다. 설정이 완료된 경우에도 초기 상태가 "offline"으로 표시된다.

파일: `vscode-extension/src/extension.ts` 133번째 줄

### 문서 불일치

없음. (기술 문서가 별도로 작성되지 않은 상태)

### 인수조건 충족

- **VS Code 익스텐션으로 설치 가능**: `package.json` 기반 VS Code 익스텐션 구조 완성, `activate`/`deactivate` 정상 구현.
- **코드 작성 중 실시간 취약점 하이라이팅**: `onDidSaveTextDocument` -> `analyzeFile()` -> `DiagnosticsManager.update()` 흐름 구현. `DiagnosticSeverity` 매핑 정확 (critical/high=Error, medium=Warning, low=Information).
- **취약점 상세 설명 패널 제공**: `WebviewManager.showDetail()` + `generateDetailHtml()` 구현. XSS 방지 이스케이프, CSP 헤더 적용.
- **Vulnix 서버 연동하여 팀 오탐 규칙 동기화**: `vulnix.syncFPPatterns` 명령으로 수동 동기화, `FPCache.matchesAny()` glob 패턴 매칭.

### 인수조건 미충족

- **패치 제안 수락 시 코드 자동 수정**: `vulnix.applyPatch` 명령이 `extension.ts`에 미등록되어 패치 적용 흐름이 동작하지 않음 (H-01).
- **취약점 위치에 인라인 패치 제안 표시**: 전구 아이콘은 표시되나, 클릭 시 실행할 `vulnix.applyPatch` 명령이 미등록되어 실질적 패치 적용이 불가 (H-01).

---

## 시각 검증

생략: VS Code 익스텐션으로 ui-spec.md 없음. 개발 서버 기반 시각 검증 대상이 아님.

---

## 의존성 보안

`npm audit`: 취약점 0건. (2026-02-25 기준)

---

## 코드 품질

### 통과

- **TypeScript strict mode 활성화**: `tsconfig.json`에 `"strict": true` 적용.
- **`any` 타입 미사용**: 전체 소스 파일에 `any` 타입 사용 없음.
- **`console.log` 미사용**: 코드베이스에 console 출력 없음.
- **하드코딩된 시크릿 없음**: API Key는 VS Code 설정(`vscode.workspace.getConfiguration`)에서 런타임에 읽어옴.
- **XSS 방지**: `panel-content.ts`에 `escapeHtml()` 함수 구현, 모든 user-data(`rule_id`, `message`, `file_path`, `code_snippet`, `cwe_id`, `owasp_category`) 이스케이프 처리.
- **Webview CSP**: `"default-src 'none'; style-src 'unsafe-inline';"` 설정으로 외부 리소스 차단 및 JavaScript 비활성화 (`enableScripts: false`).
- **이벤트 리스너 누수 방지**: `context.subscriptions.push()`로 이벤트 리스너와 명령 핸들러 등록. `deactivate()`에서 `dispose()` 호출.
- **커스텀 에러 클래스**: `AuthError`, `ServerError`, `RateLimitError` 분리로 에러 유형별 처리 가능.
- **`npm audit` 취약점 없음**: 의존성 보안 이슈 없음.

---

## 종합 판정

**FAIL** - High 이슈 1건 + Warning 이슈 6건.

| 이슈 ID | 심각도 | 요약 | 파일:라인 |
|---------|--------|------|----------|
| H-01 | High | `vulnix.applyPatch` 명령 미등록 — 패치 적용 기능 완전 불동작 | extension.ts (누락), code-actions.ts:35 |
| W-01 | Warning | API Key 형식(`vx_live_`/`vx_test_`) 검증 없음 | config.ts:33-37 |
| W-02 | Warning | 연속 저장 디바운스(500ms) 미구현 — API 중복 호출 | analyzer.ts (누락) |
| W-03 | Warning | FP 패턴 주기적 자동 동기화(`syncPeriodically`) 미구현 | fp-cache.ts (누락) |
| W-04 | Warning | 설정 변경 감지(`onDidChangeConfiguration`) 미등록 | extension.ts (누락) |
| W-05 | Warning | 웹뷰 "Apply Patch" 버튼 및 메시지 핸들러 미구현 | webview.ts:16-39, panel-content.ts |
| W-06 | Warning | patch-applier 컨텍스트 라인 무시로 범위 오차 가능 | patch-applier.ts:88-106 |

H-01(`vulnix.applyPatch` 미등록)은 F-11 핵심 인수조건인 "패치 제안 수락 시 코드 자동 수정"을 완전히 차단하는 기능 버그다. frontend-dev에게 즉시 수정을 요청한다.

수정 후 재검증 필요.
