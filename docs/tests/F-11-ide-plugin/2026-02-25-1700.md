# Quality Gate 결과: F-11 IDE 플러그인 백엔드

검증일: 2026-02-25 17:00  
검증 브랜치: main  
검증자: quality-gate

---

## 검토 대상 파일

- `backend/src/api/v1/ide.py`
- `backend/src/models/api_key.py`
- `backend/src/services/api_key_service.py`
- `backend/src/services/ide_analyzer.py`
- `backend/src/api/deps.py`
- `backend/alembic/versions/007_add_f11_tables.py`

---

## 보안

### Critical

없음.

### Warning

**W-01: timing-safe 비교 부재 (deps.py:124-128)**

`get_api_key` 함수에서 `key_hash`를 SHA-256으로 계산한 후 SQL WHERE 절로 DB에서 조회한다. DB 레벨 비교는 Python `hmac.compare_digest` 와 달리 일정 시간(constant-time) 보장이 없다. 공격자가 네트워크 타이밍을 반복 측정하여 해시 접두사를 추론할 여지가 있다. 설계서 ADR-F11-004 에서 별도 언급이 없어 Warning 수준으로 분류하지만, 향후 Redis 캐시(API Key -> team_id 매핑) 도입 시 Python 레벨 비교로 이동될 경우 반드시 `hmac.compare_digest` 를 사용해야 한다.

파일: `backend/src/api/deps.py` 라인 124-128

```python
key_hash = hashlib.sha256(x_api_key.encode()).hexdigest()
result = await db.execute(
    select(ApiKey).where(ApiKey.key_hash == key_hash)
)
```

**W-02: list_api_keys에서 revoked 키 필터링 누락 (ide.py:261-267)**

주석에는 "revoked_at이 없는 것만"이라고 명시되어 있으나, 실제 쿼리에는 `revoked_at IS NULL` 또는 `is_active = TRUE` 필터가 없다. 비활성화된 API Key가 목록에 그대로 노출된다.

파일: `backend/src/api/v1/ide.py` 라인 261-267

```python
# API Key 목록 조회 (revoked_at이 없는 것만)  <-- 주석과 실제 코드 불일치
result = await db.execute(
    select(ApiKey).where(
        ApiKey.team_id == team_id,
        # is_active 또는 revoked_at 필터 없음
    )
)
```

비교: `api_key_service.py` `list_keys` 메서드(라인 89-95)에는 `ApiKey.revoked_at == None` 필터가 올바르게 적용되어 있으나, `ide.py`의 `list_api_keys` 엔드포인트는 서비스 메서드를 재사용하지 않고 직접 쿼리를 작성하면서 누락됐다.

**W-03: 임시 디렉토리 경로 충돌 가능 (ide_analyzer.py:52-53)**

`request_id = str(uuid.uuid4())[:8]`으로 UUID v4 128비트 중 8 hex 문자(32비트)만 사용한다. 생일 역설 기준 약 65,536 동시 요청에서 충돌 확률이 50%를 넘는다. 충돌 시 `mkdir(exist_ok=True)` 로 인해 다른 요청의 임시 디렉토리에 파일을 덮어쓰는 레이스 컨디션이 발생한다.

파일: `backend/src/services/ide_analyzer.py` 라인 52-53

```python
request_id = str(uuid.uuid4())[:8]
temp_dir = Path(f"/tmp/vulnix-ide-{request_id}")
```

`semgrep_engine.py`의 `prepare_temp_dir`은 전체 job_id를 사용하는 것과 대조적이다.

**W-04: Rate Limit 미구현 (IDE 엔드포인트 전체)**

설계서 3-2절에서 Redis 기반 sliding window counter를 사용한 Rate Limit을 명시하였다:

| 엔드포인트 | 제한 |
|-----------|------|
| POST /ide/analyze | 60회/분 |
| GET /ide/false-positive-patterns | 30회/분 |
| POST /ide/patch-suggestion | 10회/분 |

현재 `ide.py`, `deps.py`, `api_key_service.py` 어디에도 Rate Limit 구현이 없다. Redis는 `pyproject.toml`에 의존성으로 포함되어 있으나 IDE 엔드포인트에서 사용되지 않는다. 특히 LLM을 호출하는 `patch-suggestion` 엔드포인트는 비용 폭발 위험이 있다.

### 통과

- **API Key 원본 값 노출 통제**: `create_key` (api_key_service.py:71-78)에서만 원본 `key` 반환. `list_api_keys` (ide.py:269-279)는 `key_prefix`만 반환하여 설계 의도 충족.
- **SHA-256 해시 저장**: DB에 원본 키 대신 `key_hash` (SHA-256 64자)만 저장. `api_key.py:41-47` 확인.
- **팀 소속 검증**: `create_api_key` 및 `revoke_api_key`에서 `TeamMember` 조회로 팀 소속 확인 (ide.py:204-209, 303-308). `revoke_key` 서비스에서 `ApiKey.team_id == team_id` 조건으로 교차 팀 접근 방지 (api_key_service.py:114-118).
- **만료/비활성 검증**: `get_api_key` (deps.py:136-154)에서 `is_active`, `expires_at` 순서대로 검증.
- **Semgrep 코드 미실행**: `semgrep_engine.py`는 `subprocess.run`으로 Semgrep CLI를 실행하고 결과를 JSON 파싱만 함. 사용자 코드를 `eval`/`exec`하는 경로 없음.
- **임시 파일 정리**: `ide_analyzer.py:87-93`에서 `finally` 블록으로 `shutil.rmtree(temp_dir)` 실행. 삭제 실패 시 예외 아닌 경고 로그로 처리하여 서비스 중단 없이 정리.
- **RBAC 적용**: `create_api_key`, `revoke_api_key` 엔드포인트에서 `role not in ("owner", "admin")` 검증 (ide.py:219-223, 317-321).
- **로그에 민감 정보 미출력**: `ide_analyzer.py` 로그에 `request_id`와 에러 메시지만 기록. 코드 내용(`content`) 미로깅.

---

## 성능

### Warning

**W-05: Semgrep 500ms 타임아웃 적용 확인 — 단, 프로세스 종료 없음**

`_run_semgrep_with_timeout` (ide_analyzer.py:95-136)에서 `asyncio.wait_for(..., timeout=0.5)`로 Python 레벨 코루틴 타임아웃은 적용되어 있다. 그러나 `executor`로 실행된 `semgrep scan` 프로세스는 `asyncio.TimeoutError` 발생 후에도 백그라운드에서 계속 실행된다. Semgrep 프로세스가 종료되지 않고 남아 CPU/메모리를 소모하며, 동시 요청이 많을 경우 좀비 프로세스가 누적된다.

파일: `backend/src/services/ide_analyzer.py` 라인 104-133

```python
findings = await asyncio.wait_for(
    loop.run_in_executor(
        None,
        lambda: self._engine.scan(temp_dir, request_id),
    ),
    timeout=_IDE_ANALYZE_TIMEOUT_SEC,
)
```

참고: Semgrep CLI 자체에는 `--timeout 300` (semgrep_engine.py:65)이 설정되어 있어 Semgrep 내부 룰 타임아웃은 존재하지만, IDE 엔드포인트에서 500ms를 초과하면 asyncio 레벨에서만 포기하고 프로세스는 살아 있다.

### 통과

- **Semgrep 500ms 타임아웃 설정**: `_IDE_ANALYZE_TIMEOUT_SEC = 0.5` (ide_analyzer.py:20) 로 정의되고 `asyncio.wait_for`에 적용됨.
- **임시 파일 경로**: UUID 기반 디렉토리로 경로 예측 불가 (W-03에서 길이 이슈 언급, 기능 자체는 동작).
- **인덱스 설계 반영**: 마이그레이션(007)에서 `idx_api_key_hash` (UNIQUE), `idx_api_key_team`, `idx_api_key_active` 부분 인덱스 모두 적용됨. 설계서 8-3절 인덱스 계획 충족.
- **ETag 캐싱**: `false-positive-patterns` 엔드포인트에 SHA-256 기반 ETag 생성 및 304 응답 구현 (ide.py:116-126).

---

## 설계/문서 일치

### 설계 불일치

**D-01: 헤더 이름 불일치 — 설계서 `X-API-Key` vs 구현 `X-Api-Key`**

설계서(design.md:43, 68, 131, 169) 및 test-spec.md(라인 81-82)에서 `X-API-Key`로 명시. 구현 코드(deps.py:101)와 API 문서(docs/api/F-11-ide-plugin.md:12)는 `X-Api-Key`로 구현. HTTP 헤더는 대소문자를 무시하므로 실제 동작에는 문제없으나 문서 일관성이 없다.

**D-02: `list_api_keys` — `ApiKeyService.list_keys` 미사용**

`api_key_service.py:80-95`에 `list_keys` 메서드가 구현되어 있고 `revoked_at IS NULL` 필터를 올바르게 포함한다. 그러나 `ide.py`의 `list_api_keys` 엔드포인트(라인 250-286)는 이 메서드를 호출하지 않고 직접 쿼리를 재작성하면서 필터를 누락시켰다 (W-02와 동일 이슈).

**D-03: 설계서 INVALID_LANGUAGE 에러 vs 실제 422 응답**

설계서(design.md:118-119)는 지원하지 않는 언어 요청 시 `400 INVALID_LANGUAGE`를 명시. API 문서(docs/api/F-11-ide-plugin.md)는 `422`로 수정 기록됨. 실제 구현에서 `IdeAnalyzeRequest.validate_language` Pydantic validator가 유효하지 않은 언어를 거부하면 FastAPI는 기본적으로 `422 Unprocessable Entity`를 반환한다. 설계서와 구현 간 불일치가 있으나 API 문서가 이를 반영하고 있어 API 문서 기준으로는 일치.

### 문서 불일치

**D-04: 설계서 Redis 캐싱 전략 미구현**

설계서 8-4절에서 "API Key -> team_id 매핑을 Redis에 TTL 5분으로 캐싱"을 명시하였으나, 구현 코드에서 이 캐싱은 전혀 구현되지 않았다. 현재 모든 IDE API 요청마다 DB를 조회한다.

### 인수조건 충족

- **코드 작성 중 실시간 취약점 하이라이팅**: 백엔드 `POST /ide/analyze` 엔드포인트 구현, Semgrep 500ms 타임아웃으로 IDE에 최적화된 응답 구조 제공. 충족.
- **취약점 위치에 인라인 패치 제안 표시**: 백엔드 `POST /ide/patch-suggestion` 엔드포인트 구현. 충족.
- **패치 제안 수락 시 코드 자동 수정**: 백엔드 측 `generate_patch` 응답 구조(`patch_diff`, `patch_description`) 구현. 충족 (VS Code 측 적용 로직은 이번 검토 범위 외).
- **취약점 상세 설명 패널**: 백엔드 응답에 `cwe_id`, `owasp_category`, `vulnerability_type` 포함. 충족.
- **팀 오탐 규칙 동기화**: `GET /ide/false-positive-patterns` + ETag 캐싱 구현. 충족.

### 인수조건 미충족

- **Rate Limit**: 설계서 명시 Rate Limit 미구현. 특히 `patch-suggestion`의 분당 10회 제한 부재.

---

## 시각 검증

생략: 백엔드 전용 기능으로 ui-spec.md 없음.

---

## Alembic 마이그레이션 체인 확인

- `007_add_f11_tables.py:19` — `down_revision = "006_add_f10_tables"` 확인. 체인 정상.
- `006_add_f10_tables.py` 존재 확인. 선행 마이그레이션 의존성 정상.

---

## 종합 판정

**PASS (조건부)** — Critical 이슈 0건. Warning 5건.

| 이슈 ID | 분류 | 요약 | 파일:라인 |
|---------|------|------|----------|
| W-01 | Warning | API Key 조회가 DB 레벨 비교로만 처리 (constant-time 미보장) | deps.py:124-128 |
| W-02 | Warning | list_api_keys에서 revoked 키 필터 누락 (주석-코드 불일치) | ide.py:261-267 |
| W-03 | Warning | 임시 디렉토리 request_id를 UUID[:8]로 자름 (32비트 충돌 위험) | ide_analyzer.py:52-53 |
| W-04 | Warning | Rate Limit 미구현 (설계서 명시, 특히 patch-suggestion LLM 비용 위험) | ide.py 전체 |
| W-05 | Warning | 500ms 타임아웃 초과 시 Semgrep 프로세스가 백그라운드에 잔존 | ide_analyzer.py:104-133 |

W-02는 기능 버그(비활성화된 키 노출)에 해당하므로 수정이 권장된다.  
W-04(Rate Limit)는 LLM 비용 및 서비스 안정성과 직결되므로 프로덕션 배포 전 필수 구현이 필요하다.
